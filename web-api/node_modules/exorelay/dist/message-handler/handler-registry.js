// Generated by LiveScript 1.5.0
var ref$, bold, red, debug, EventEmitter, HandlerRegistry;
ref$ = require('chalk'), bold = ref$.bold, red = ref$.red;
debug = require('debug');
EventEmitter = require('events').EventEmitter;
HandlerRegistry = (function(superclass){
  var prototype = extend$((import$(HandlerRegistry, superclass).displayName = 'HandlerRegistry', HandlerRegistry), superclass).prototype, constructor = HandlerRegistry;
  function HandlerRegistry(debugName){
    this.handlers = {};
    this.debug = debug("exorelay:" + debugName);
  }
  HandlerRegistry.prototype.getHandler = function(messageId){
    return this.handlers[messageId];
  };
  HandlerRegistry.prototype.handleCommand = function(arg$, methods){
    var messageName, payload, handler, e;
    messageName = arg$.messageName, payload = arg$.payload;
    if (handler = this.getHandler(messageName)) {
      debug("handling message '" + messageName + "'");
      try {
        handler(payload, methods);
      } catch (e$) {
        e = e$;
        console.log("\n" + red(bold(e.message)) + "\n");
        console.log(e.stack);
        throw e;
      }
    }
    return !!handler;
  };
  HandlerRegistry.prototype.handleReply = function(arg$){
    var messageName, responseTo, payload, handler, e;
    messageName = arg$.messageName, responseTo = arg$.responseTo, payload = arg$.payload;
    if (handler = this.getHandler(responseTo)) {
      debug("handling message '" + messageName + "' in response to '" + responseTo + "'");
      try {
        handler(payload, {
          outcome: messageName
        });
      } catch (e$) {
        e = e$;
        console.log("\n" + red(bold(e.message)) + "\n");
        console.log(e.stack);
        throw e;
      }
    }
    return !!handler;
  };
  HandlerRegistry.prototype.hasHandler = function(messageId){
    return typeof this.getHandler(messageId) === 'function';
  };
  HandlerRegistry.prototype.registerHandler = function(messageId, handler){
    switch (false) {
    case !!messageId:
      return this.emit('error', new Error('No message id provided'));
    case typeof messageId === 'string':
      return this.emit('error', new Error('Message ids must be strings'));
    case !!handler:
      return this.emit('error', new Error('No message handler provided'));
    case typeof handler === 'function':
      return this.emit('error', new Error('Message handler must be a function'));
    case !this.hasHandler(messageId):
      return this.emit('error', new Error("There is already a handler for message '" + messageId + "'"));
    }
    this.debug("registering handler for id '" + messageId + "'");
    return this.handlers[messageId] = handler;
  };
  HandlerRegistry.prototype.registerHandlers = function(handlers){
    var messageId, handler, results$ = [];
    for (messageId in handlers) {
      handler = handlers[messageId];
      results$.push(this.registerHandler(messageId, handler));
    }
    return results$;
  };
  return HandlerRegistry;
}(EventEmitter));
module.exports = HandlerRegistry;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}