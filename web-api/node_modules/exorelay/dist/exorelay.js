// Generated by LiveScript 1.5.0
var EventEmitter, HandlerManager, MessageSender, ref$, delegate, delegateEvent, ZmqListener, debug, ExoRelay;
EventEmitter = require('events').EventEmitter;
HandlerManager = require('./message-handler/message-manager');
MessageSender = require('./message-sender/message-sender');
ref$ = require('rails-delegate'), delegate = ref$.delegate, delegateEvent = ref$.delegateEvent;
ZmqListener = require('./zmq-listener/zmq-listener');
debug = require('debug')('exorelay');
ExoRelay = (function(superclass){
  var prototype = extend$((import$(ExoRelay, superclass).displayName = 'ExoRelay', ExoRelay), superclass).prototype, constructor = ExoRelay;
  function ExoRelay(config){
    var x$;
    this._onIncomingMessage = bind$(this, '_onIncomingMessage', prototype);
    this.send = bind$(this, 'send', prototype);
    (config != null && config.exocomPort) || (function(){
      throw new Error('exocomPort not provided');
    }());
    (config != null && config.serviceName) || (function(){
      throw new Error('serviceName not provided');
    }());
    this.messageHandler = new HandlerManager();
    this.messageSender = new MessageSender(config);
    x$ = this.zmqListener = new ZmqListener();
    x$.on('message', this._onIncomingMessage);
    delegate('closePort', {
      from: this,
      to: this.messageSender
    });
    delegate('close', 'listen', 'port', {
      from: this,
      to: this.zmqListener
    });
    delegate('hasHandler', 'registerHandler', 'registerHandlers', {
      from: this,
      to: this.messageHandler
    });
    delegateEvent('error', {
      from: [this.zmqListener, this.messageHandler, this.messageSender],
      to: this
    });
    delegateEvent('status', 'online', 'offline', {
      from: this.zmqListener,
      to: this
    });
  }
  ExoRelay.prototype.send = function(messageName, payload, replyHandler){
    var messageId;
    switch (false) {
    case !(replyHandler && typeof replyHandler !== 'function'):
      return this.emit('error', Error('The reply handler given to ExoRelay#send must be a function'));
    }
    messageId = this.messageSender.send(messageName, payload);
    if (replyHandler) {
      this.messageHandler.registerReplyHandler(messageId, replyHandler);
    }
    return messageId;
  };
  ExoRelay.prototype._onIncomingMessage = function(requestData){
    if (requestData.messageName === '__status') {
      this.messageSender.send("__status-ok");
      return 'success';
    }
    if (!requestData.id) {
      return 'missing message id';
    }
    return this.messageHandler.handleRequest(requestData, {
      reply: this.messageSender.replyMethodFor(requestData.id),
      send: this.send
    });
  };
  return ExoRelay;
}(EventEmitter));
module.exports = ExoRelay;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}