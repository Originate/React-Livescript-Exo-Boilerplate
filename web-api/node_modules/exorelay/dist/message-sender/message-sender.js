// Generated by LiveScript 1.5.0
var EventEmitter, isEmpty, uuid, zmq, debug, MessageSender;
EventEmitter = require('events').EventEmitter;
isEmpty = require('lodash.isempty');
uuid = require('node-uuid');
zmq = require('zmq');
debug = require('debug')('exorelay:message-sender');
MessageSender = (function(superclass){
  var prototype = extend$((import$(MessageSender, superclass).displayName = 'MessageSender', MessageSender), superclass).prototype, constructor = MessageSender;
  function MessageSender(arg$){
    var ref$, x$;
    ref$ = arg$ != null
      ? arg$
      : {}, this.serviceName = ref$.serviceName, this.exocomPort = ref$.exocomPort;
    this.exocomPort = +this.exocomPort;
    if (!this.exocomPort) {
      throw new Error('ExoCom port not provided');
    }
    x$ = this.socket = zmq.socket('push');
    x$.connect("tcp://localhost:" + this.exocomPort);
    this.lastSentId = null;
  }
  MessageSender.prototype.closePort = function(){
    return this.socket.close();
  };
  MessageSender.prototype.replyMethodFor = function(id){
    var this$ = this;
    switch (false) {
    case !!id:
      return this.emit('error', new Error('MessageSender.replyMethodFor needs a id'));
    }
    return function(messageName, payload){
      return this$.send(messageName, payload, {
        responseTo: id
      });
    };
  };
  MessageSender.prototype.send = function(messageName, payload, options){
    var requestData;
    options == null && (options = {});
    switch (false) {
    case !!messageName:
      return this.emit('error', new Error('ExoRelay#send cannot send empty messages'));
    case typeof messageName === 'string':
      return this.emit('error', new Error('ExoRelay#send can only send string messages'));
    case typeof payload !== 'function':
      return this.emit('error', new Error('ExoRelay#send cannot send functions as payload'));
    }
    this._log(messageName, options);
    requestData = {
      name: messageName,
      sender: this.serviceName,
      id: uuid.v1()
    };
    if (payload != null) {
      requestData.payload = payload;
    }
    if (options.responseTo) {
      requestData.responseTo = options.responseTo;
    }
    this.socket.send(JSON.stringify(requestData));
    return this.lastSentId = requestData.id;
  };
  MessageSender.prototype._log = function(messageName, options){
    switch (false) {
    case !options.responseTo:
      return debug("sending message '" + messageName + "' in response to '" + options.responseTo + "'");
    default:
      return debug("sending message '" + messageName + "'");
    }
  };
  return MessageSender;
}(EventEmitter));
module.exports = MessageSender;
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}