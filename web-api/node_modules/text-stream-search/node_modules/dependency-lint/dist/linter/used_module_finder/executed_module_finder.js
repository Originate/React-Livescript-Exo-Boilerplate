(function() {
  var ExecutedModulesFinder, ModuleNameParser, _, async, asyncHandlers, fs, glob, path,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  async = require('async');

  asyncHandlers = require('async-handlers');

  fs = require('fs');

  glob = require('glob');

  ModuleNameParser = require('./module_name_parser');

  path = require('path');

  ExecutedModulesFinder = (function() {
    function ExecutedModulesFinder(arg) {
      this.shellScripts = arg.shellScripts;
      this.findModuleExecutableUsage = bind(this.findModuleExecutableUsage, this);
    }

    ExecutedModulesFinder.prototype.find = function(arg, done) {
      var dir, getUsage, packageJson, packageJsonScripts;
      dir = arg.dir, packageJson = arg.packageJson;
      packageJsonScripts = packageJson.scripts || {};
      getUsage = (function(_this) {
        return function(arg1) {
          var moduleExecutables, shellScripts;
          moduleExecutables = arg1[0], shellScripts = arg1[1];
          return _this.findModuleExecutableUsage({
            moduleExecutables: moduleExecutables,
            packageJsonScripts: packageJsonScripts,
            shellScripts: shellScripts
          });
        };
      })(this);
      return async.parallel([
        (function(_this) {
          return function(cb) {
            return _this.getModuleExecutables(dir, cb);
          };
        })(this), (function(_this) {
          return function(cb) {
            return _this.readShellScripts(dir, cb);
          };
        })(this)
      ], asyncHandlers.transform(getUsage, done));
    };

    ExecutedModulesFinder.prototype.findInScript = function(script, moduleExecutables) {
      var executable, executables, i, len, moduleName, result;
      result = [];
      for (moduleName in moduleExecutables) {
        executables = moduleExecutables[moduleName];
        for (i = 0, len = executables.length; i < len; i++) {
          executable = executables[i];
          if (ModuleNameParser.isGlobalExecutable(executable)) {
            continue;
          }
          if (script.match(executable) && indexOf.call(result, moduleName) < 0) {
            result.push(moduleName);
          }
        }
      }
      return result;
    };

    ExecutedModulesFinder.prototype.findModuleExecutableUsage = function(arg) {
      var fileContent, filePath, i, j, len, len1, moduleExecutables, moduleName, packageJsonScripts, ref, ref1, result, script, scriptName, shellScripts;
      moduleExecutables = arg.moduleExecutables, packageJsonScripts = arg.packageJsonScripts, shellScripts = arg.shellScripts;
      result = [];
      for (scriptName in packageJsonScripts) {
        script = packageJsonScripts[scriptName];
        ref = this.findInScript(script, moduleExecutables);
        for (i = 0, len = ref.length; i < len; i++) {
          moduleName = ref[i];
          result.push({
            name: moduleName,
            script: scriptName
          });
        }
      }
      for (filePath in shellScripts) {
        fileContent = shellScripts[filePath];
        ref1 = this.findInScript(fileContent, moduleExecutables);
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          moduleName = ref1[j];
          result.push({
            name: moduleName,
            file: filePath
          });
        }
      }
      return result;
    };

    ExecutedModulesFinder.prototype.getModuleExecutables = function(dir, done) {
      var binPath;
      binPath = path.join(dir, 'node_modules', '.bin');
      return async.auto({
        executables: function(next) {
          return fs.access(binPath, function(err) {
            if (err) {
              return done(null, []);
            }
            return fs.readdir(binPath, next);
          });
        },
        links: [
          'executables', function(next, arg) {
            var executables, files;
            executables = arg.executables;
            files = executables.map(function(file) {
              return path.join(binPath, file);
            });
            return async.map(files, fs.readlink, next);
          }
        ]
      }, asyncHandlers.transform(this.parseModuleExecutables, done));
    };

    ExecutedModulesFinder.prototype.parseModuleExecutables = function(arg) {
      var executables, links, result;
      executables = arg.executables, links = arg.links;
      result = {};
      links.forEach(function(link, index) {
        var name;
        name = ModuleNameParser.stripSubpath(path.relative('..', link));
        if (!result[name]) {
          result[name] = [];
        }
        return result[name].push(path.basename(executables[index]));
      });
      return result;
    };

    ExecutedModulesFinder.prototype.readShellScripts = function(dir, done) {
      return glob(this.shellScripts.root, {
        cwd: dir,
        ignore: this.shellScripts.ignore
      }, function(err, filePaths) {
        var iterator, zip;
        if (err) {
          return done(err);
        }
        iterator = function(filePath, next) {
          return fs.readFile(path.join(dir, filePath), {
            encoding: 'utf8'
          }, next);
        };
        zip = function(fileContents) {
          return _.zipObject(filePaths, fileContents);
        };
        return async.map(filePaths, iterator, asyncHandlers.transform(zip, done));
      });
    };

    return ExecutedModulesFinder;

  })();

  module.exports = ExecutedModulesFinder;

}).call(this);
