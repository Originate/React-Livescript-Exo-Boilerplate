(function() {
  var ExecutedModulesFinder, ModuleNameParser, _, async, asyncHandlers, fs, fsExtra, glob, path,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ = require('lodash');

  async = require('async');

  asyncHandlers = require('async-handlers');

  fs = require('fs');

  fsExtra = require('fs-extra');

  glob = require('glob');

  ModuleNameParser = require('./module_name_parser');

  path = require('path');

  ExecutedModulesFinder = (function() {
    function ExecutedModulesFinder(arg) {
      this.shellScripts = arg.shellScripts;
      this.findModuleExecutableUsage = bind(this.findModuleExecutableUsage, this);
    }

    ExecutedModulesFinder.prototype.find = function(arg, done) {
      var dir, getUsage, packageJson, packageJsonScripts;
      dir = arg.dir, packageJson = arg.packageJson;
      packageJsonScripts = packageJson.scripts || {};
      getUsage = (function(_this) {
        return function(arg1) {
          var moduleExecutables, shellScripts;
          moduleExecutables = arg1[0], shellScripts = arg1[1];
          return _this.findModuleExecutableUsage({
            moduleExecutables: moduleExecutables,
            packageJsonScripts: packageJsonScripts,
            shellScripts: shellScripts
          });
        };
      })(this);
      return async.parallel([
        (function(_this) {
          return function(cb) {
            return _this.getModuleExecutables(dir, cb);
          };
        })(this), (function(_this) {
          return function(cb) {
            return _this.readShellScripts(dir, cb);
          };
        })(this)
      ], asyncHandlers.transform(getUsage, done));
    };

    ExecutedModulesFinder.prototype.findInScript = function(script, moduleExecutables) {
      var executable, executables, i, len, moduleName, result;
      result = [];
      for (moduleName in moduleExecutables) {
        executables = moduleExecutables[moduleName];
        for (i = 0, len = executables.length; i < len; i++) {
          executable = executables[i];
          if (ModuleNameParser.isGlobalExecutable(executable)) {
            continue;
          }
          if (script.match(executable) && indexOf.call(result, moduleName) < 0) {
            result.push(moduleName);
          }
        }
      }
      return result;
    };

    ExecutedModulesFinder.prototype.findModuleExecutableUsage = function(arg) {
      var fileContent, filePath, i, j, len, len1, moduleExecutables, moduleName, packageJsonScripts, ref, ref1, result, script, scriptName, shellScripts;
      moduleExecutables = arg.moduleExecutables, packageJsonScripts = arg.packageJsonScripts, shellScripts = arg.shellScripts;
      result = [];
      for (scriptName in packageJsonScripts) {
        script = packageJsonScripts[scriptName];
        ref = this.findInScript(script, moduleExecutables);
        for (i = 0, len = ref.length; i < len; i++) {
          moduleName = ref[i];
          result.push({
            name: moduleName,
            script: scriptName
          });
        }
      }
      for (filePath in shellScripts) {
        fileContent = shellScripts[filePath];
        ref1 = this.findInScript(fileContent, moduleExecutables);
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          moduleName = ref1[j];
          result.push({
            name: moduleName,
            file: filePath
          });
        }
      }
      return result;
    };

    ExecutedModulesFinder.prototype.getModuleExecutables = function(dir, done) {
      var nodeModulesPath;
      nodeModulesPath = path.join(dir, 'node_modules');
      return glob(nodeModulesPath + "/{*,*/*}/package.json", function(err, files) {
        var iterator;
        if (err) {
          return done(err);
        }
        iterator = function(file, cb) {
          return fsExtra.readJson(file, function(err, packageJson) {
            var executables;
            if (err) {
              return cb(err);
            }
            executables = _.isString(packageJson.bin) ? [packageJson.name] : _.isObject(packageJson.bin) ? _.keys(packageJson.bin) : [];
            return cb(null, [packageJson.name, executables]);
          });
        };
        return async.map(files, iterator, asyncHandlers.transform(_.fromPairs, done));
      });
    };

    ExecutedModulesFinder.prototype.readShellScripts = function(dir, done) {
      return glob(this.shellScripts.root, {
        cwd: dir,
        ignore: this.shellScripts.ignore
      }, function(err, filePaths) {
        var iterator, zip;
        if (err) {
          return done(err);
        }
        iterator = function(filePath, next) {
          return fs.readFile(path.join(dir, filePath), {
            encoding: 'utf8'
          }, next);
        };
        zip = function(fileContents) {
          return _.zipObject(filePaths, fileContents);
        };
        return async.map(filePaths, iterator, asyncHandlers.transform(zip, done));
      });
    };

    return ExecutedModulesFinder;

  })();

  module.exports = ExecutedModulesFinder;

}).call(this);
