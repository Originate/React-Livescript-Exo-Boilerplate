// Generated by LiveScript 1.5.0
var async, red, child_process, EventEmitter, fs, yaml, path, rimraf, ServiceCloner, AppCloner;
async = require('async');
red = require('chalk').red;
child_process = require('child_process');
EventEmitter = require('events').EventEmitter;
fs = require('fs');
yaml = require('js-yaml');
path = require('path');
rimraf = require('rimraf');
ServiceCloner = require('./service-cloner');
AppCloner = (function(superclass){
  var prototype = extend$((import$(AppCloner, superclass).displayName = 'AppCloner', AppCloner), superclass).prototype, constructor = AppCloner;
  function AppCloner(repository){
    this.repository = repository;
    this._log = bind$(this, '_log', prototype);
  }
  AppCloner.prototype.start = function(){
    var this$ = this;
    if (this.gitCloneApp(process.cwd(), this.repository.origin)) {
      return this.emit('app-clone-failed');
    }
    this.emit('app-clone-success');
    return this.verifyIsExoApp(function(err){
      var configPath, cloners, res$, i$, ref$, len$, serviceName, serviceRoot, serviceDir, serviceOrigin, x$, cloner;
      switch (false) {
      case !err:
        return this$.emit('app-verification-failed', err);
      }
      configPath = path.join(this$.repository.path, 'application.yml');
      this$.appConfig = yaml.safeLoad(fs.readFileSync(configPath, 'utf8'));
      this$.emit('app-config-ready', this$.appConfig);
      res$ = [];
      for (i$ = 0, len$ = (ref$ = Object.keys(this$.appConfig.services)).length; i$ < len$; ++i$) {
        serviceName = ref$[i$];
        serviceRoot = path.join(this$.repository.path, path.dirname(this$.appConfig.services[serviceName].local));
        serviceDir = path.join(this$.repository.path, this$.appConfig.services[serviceName].local);
        serviceOrigin = this$.appConfig.services[serviceName].origin;
        x$ = new ServiceCloner(serviceName, {
          root: serviceRoot,
          path: serviceDir,
          origin: serviceOrigin
        });
        x$.on('service-clone-success', fn$);
        x$.on('service-clone-fail', fn1$);
        x$.on('service-invalid', fn2$);
        x$.on('output', fn3$);
        res$.push(x$);
      }
      cloners = res$;
      return async.series((function(){
        var i$, ref$, len$, results$ = [];
        for (i$ = 0, len$ = (ref$ = cloners).length; i$ < len$; ++i$) {
          cloner = ref$[i$];
          if (cloner.config.origin) {
            results$.push(cloner.start);
          }
        }
        return results$;
      }()), function(err, exitCodes){
        switch (false) {
        case !err:
          return this$.emit('service-clones-failed');
        case !this$._containsNonZero(exitCodes):
          return this$.emit('service-clones-failed');
        default:
          return this$.emit('all-clones-successful');
        }
      });
      function fn$(name){
        return this$.emit('service-clone-success', name);
      }
      function fn1$(name){
        return this$.emit('service-clone-fail', name);
      }
      function fn2$(name){
        return this$.emit('service-invalid', name);
      }
      function fn3$(data){
        return this$.emit('output', data);
      }
    });
  };
  AppCloner.prototype._log = function(text){
    return this.emit('output', {
      name: 'exo-clone',
      text: text,
      trim: true
    });
  };
  AppCloner.prototype._containsNonZero = function(exitCodes){
    var this$ = this;
    return exitCodes.filter((function(it){
      return it > 0;
    })).length > 0;
  };
  AppCloner.prototype.gitCloneApp = function(cwd, origin){
    var output;
    output = child_process.spawnSync("git", ("clone " + origin).split(' '), {
      cwd: cwd,
      stdio: [1, 2]
    });
    switch (output.status) {
    case 0:
      this._log(output.stderr.toString().trim());
      break;
    default:
      this._log(red(output.stderr.toString().trim()));
    }
    return output.status;
  };
  AppCloner.prototype.removeDir = function(dirPath){
    return rimraf(dirPath, function(error){
      switch (false) {
      case !error:
        return this._log("Could not remove " + dirPath);
      }
    });
  };
  AppCloner.prototype.verifyIsExoApp = function(callback){
    var err;
    try {
      return fs.accessSync(path.join(this.repository.path, 'application.yml'));
    } catch (e$) {
      err = e$;
      return this.removeDir(this.repository.path);
    } finally {
      callback(err);
    }
  };
  return AppCloner;
}(EventEmitter));
module.exports = AppCloner;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}