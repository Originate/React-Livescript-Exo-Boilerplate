// Generated by LiveScript 1.5.0
var spawn, EventEmitter, extend, mergeStream, path, request, stringArgv, TextStreamSearch, debug, ObservableProcess, slice$ = [].slice;
spawn = require('child_process').spawn;
EventEmitter = require('events');
extend = require('extend');
mergeStream = require('merge-stream');
path = require('path');
request = require('request');
stringArgv = require('string-argv');
TextStreamSearch = require('text-stream-search');
debug = require('debug')('observable-process');
ObservableProcess = (function(superclass){
  var prototype = extend$((import$(ObservableProcess, superclass).displayName = 'ObservableProcess', ObservableProcess), superclass).prototype, constructor = ObservableProcess;
  function ObservableProcess(command, arg$){
    var ref$, options, runnable, params, x$, this$ = this;
    ref$ = arg$ != null
      ? arg$
      : {}, this.env = ref$.env, this.verbose = ref$.verbose, this.cwd = ref$.cwd, this.stdout = ref$.stdout, this.stderr = ref$.stderr, this.console = ref$.console;
    this.onClose = bind$(this, 'onClose', prototype);
    switch (false) {
    case this.console == null:
      throw new Error('Deprecated option: console\nPlease use the new options "stdout" and "stderr"');
    }
    this.stdout == null && (this.stdout = process.stdout);
    this.stderr == null && (this.stderr = process.stderr);
    options = {
      env: {}
    };
    extend(options.env, process.env, this.env);
    if (this.cwd) {
      options.cwd = this.cwd;
    }
    this.ended = false;
    ref$ = this._splitCommand(command), runnable = ref$[0], params = slice$.call(ref$, 1);
    debug("starting '" + runnable + "' with arguments '" + params + "'");
    x$ = this.process = spawn(runnable, params, options);
    x$.on('close', this.onClose);
    this.textStreamSearch = new TextStreamSearch(mergeStream(this.process.stdout, this.process.stderr));
    if (this.stdout) {
      this.process.stdout.on('data', function(data){
        return this$.stdout.write(data.toString());
      });
    }
    if (this.stderr) {
      this.process.stderr.on('data', function(data){
        return this$.stderr.write(data.toString());
      });
    }
    this.killed = false;
    this.stdin = this.process.stdin;
  }
  ObservableProcess.prototype.enter = function(text){
    return this.stdin.write(text + "\n");
  };
  ObservableProcess.prototype.fullOutput = function(){
    return this.textStreamSearch.fullText();
  };
  ObservableProcess.prototype.kill = function(){
    this.killed = true;
    return this.process.kill();
  };
  ObservableProcess.prototype.onClose = function(exitCode){
    var ref$, ref1$;
    this.exitCode = exitCode;
    this.ended = true;
    if (this.verbose) {
      if ((ref$ = this.stderr) != null) {
        ref$.write('PROCESS ENDED\n');
      }
      if ((ref1$ = this.stderr) != null) {
        ref1$.write("\nEXIT CODE: " + this.exitCode);
      }
    }
    return this.emit('ended', this.exitCode, this.killed);
  };
  ObservableProcess.prototype.pid = function(){
    var ref$;
    return (ref$ = this.process) != null ? ref$.pid : void 8;
  };
  ObservableProcess.prototype.wait = function(text, handler){
    return this.textStreamSearch.wait(text, handler);
  };
  ObservableProcess.prototype.resetOutputStreams = function(){
    return this.textStreamSearch.reset();
  };
  ObservableProcess.prototype._splitCommand = function(command){
    if (Array.isArray(command)) {
      return command;
    } else {
      return stringArgv(command);
    }
  };
  return ObservableProcess;
}(EventEmitter));
module.exports = ObservableProcess;
function bind$(obj, key, target){
  return function(){ return (target || obj)[key].apply(obj, arguments) };
}
function extend$(sub, sup){
  function fun(){} fun.prototype = (sub.superclass = sup).prototype;
  (sub.prototype = new fun).constructor = sub;
  if (typeof sup.extended == 'function') sup.extended(sub);
  return sub;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}